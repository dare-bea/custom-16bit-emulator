Op	Mnem.	Oper. 1	Oper. 2	Oper. 3	Bytes	Description
00	LD	addr			3	Load byte at [addr] into A
01	LD	addr	SP		3	Load byte at [addr + SP] into A
01	LD	!0	!0	SP	3	Load byte at [SP] into A
02						
03	LDS	dst	src		2	Load byte from memory addressed by src into dst register
04	LDW	addr			3	Load word at [addr] into A
05	LDW	addr	SP		3	Load word at [addr + SP] into A
05	LDW	!0	!0	SP	3	Load word at [SP] into A
06						
07	LDSW	dst	src		2	Load word from memory addressed by src into dst register
08	LD	addr	A		3	Load byte at [addr + A] into A
08	LD	!0	!0	A	3	Load byte at [A] into A
09	LD	addr	B		3	Load byte at [addr + B] into A
09	LD	!0	!0	B	3	Load byte at [B] into A
0A	LD	addr	C		3	Load byte at [addr + C] into A
0A	LD	!0	!0	C	3	Load byte at [C] into A
0B	LD	addr	D		3	Load byte at [addr + D] into A
0B	LD	!0	!0	D	3	Load byte at [D] into A
0C	LDW	addr	A		3	Load word at [addr + A] into A
0C	LDW	!0	!0	A	3	Load word at [A] into A
0D	LDW	addr	B		3	Load word at [addr + B] into A
0D	LDW	!0	!0	B	3	Load word at [B] into A
0E	LDW	addr	C		3	Load word at [addr + C] into A
0E	LDW	!0	!0	C	3	Load word at [C] into A
0F	LDW	addr	D		3	Load word at [addr + D] into A
0F	LDW	!0	!0	D	3	Load word at [D] into A
10	ST	addr			3	Store byte from A into memory at [addr]
11	ST	addr	SP		3	Store byte from A into memory at [addr + SP]
11	ST	!0	!0	SP	3	Store byte from A into memory at [SP]
12						
13	STS	src	dst		2	Store byte from src into memory addressed by dst register
14	STW	addr			3	Store word from A into memory at [addr]
15	STW	addr	SP		3	Store word from A into memory at [addr + SP]
15	STW	!0	!0	SP	3	Store word from A into memory at [SP]
16						
17	STSW	src	dst		2	Store word from src into memory addressed by dst register
18	ST	addr	A		3	Store byte from A into memory at [addr + A]
18	ST	!0	!0	A	3	Store byte from A into memory at [A]
19	ST	addr	B		3	Store byte from A into memory at [addr + B]
19	ST	!0	!0	B	3	Store byte from A into memory at [B]
1A	ST	addr	C		3	Store byte from A into memory at [addr + C]
1A	ST	!0	!0	C	3	Store byte from A into memory at [C]
1B	ST	addr	D		3	Store byte from A into memory at [addr + D]
1B	ST	!0	!0	D	3	Store byte from A into memory at [D]
1C	STW	addr	A		3	Store word from A into memory at [addr + A]
1C	STW	!0	!0	A	3	Store word from A into memory at [A]
1D	STW	addr	B		3	Store word from A into memory at [addr + B]
1D	STW	!0	!0	B	3	Store word from A into memory at [B]
1E	STW	addr	C		3	Store word from A into memory at [addr + C]
1E	STW	!0	!0	C	3	Store word from A into memory at [C]
1F	STW	addr	D		3	Store word from A into memory at [addr + D]
1F	STW	!0	!0	D	3	Store word from A into memory at [D]
20	LDI	A	#imm8		2	Load 8-bit immediate into A
21	LDI	B	#imm8		2	Load 8-bit immediate into B
22	LDI	C	#imm8		2	Load 8-bit immediate into C
23	LDI	D	#imm8		2	Load 8-bit immediate into D
24	LDI	A	#imm16		3	Load 16-bit immediate into A
25	LDI	B	#imm16		3	Load 16-bit immediate into B
26	LDI	C	#imm16		3	Load 16-bit immediate into C
27	LDI	D	#imm16		3	Load 16-bit immediate into D
28	JMP	rel	PC		2	Add signed offset to PC
29	JMP	addr			3	Jump to absolute address
2A	JMPI	addr	SP		3	Jump to address at [addr + SP]
2B	MOV	dst	src		2	Copy value from src to dst register
2C	JMPI	addr	A		3	Jump to address at [addr + A]
2D	JMPI	addr	B		3	Jump to address at [addr + B]
2E	JMPI	addr	C		3	Jump to address at [addr + C]
2F	JMPI	addr	D		3	Jump to address at [addr + D]
30	J{cc}	rel	PC		2	Conditional relative jump from PC
31	J{cc}	addr			3	Conditional absolute jump
32	J{cc}I	addr	SP		3	Conditional jump to address at [addr + SP]
33	MOV{cc}	dst	src		2	Conditional register move
34	J{cc}I	addr	A		3	Conditional jump to address at [addr + A]
35	J{cc}I	addr	B		3	Conditional jump to address at [addr + B]
36	J{cc}I	addr	C		3	Conditional jump to address at [addr + C]
37	J{cc}I	addr	D		3	Conditional jump to address at [addr + D]
38	CALL	rel	PC		2	Push PC and perform relative subroutine call
39	CALL	addr			3	Push PC and call absolute address
3A	CALLI	addr	SP		3	Push PC and call address at [addr + SP]
3B	PUSHMOV	dst	src		2	Push src register, then copy src to dst
3C	CALLI	addr	A		3	Push PC and call address at [addr + A]
3D	CALLI	addr	B		3	Push PC and call address at [addr + B]
3E	CALLI	addr	C		3	Push PC and call address at [addr + C]
3F	CALLI	addr	D		3	Push PC and call address at [addr + D]
40	PUSH	A			1	Push A onto stack
41	PUSH	B			1	Push B onto stack
42	PUSH	C			1	Push C onto stack
43	PUSH	D			1	Push D onto stack
44						
45	PUSH	SP			1	Push SP onto stack
46	PUSH	PC			1	Push PC onto stack
47	PUSH	FLAGS			1	Push FLAGS onto stack
48	POP	A			1	Pop stack into A
49	POP	B			1	Pop stack into B
4A	POP	C			1	Pop stack into C
4B	POP	D			1	Pop stack into D
4C						
4D	POP	SP			1	Pop stack into SP
4E	POP	PC			1	Pop stack into PC
4E	RET				1	Return from subroutine
4F	POP	FLAGS			1	Pop stack into FLAGS
50	MOVS	dst	src		2	Move byte from memory addressed by src to memory addressed by dst
51	NOP				1	No operation
52						
53						
54						
55						
56						
57						
58						
59						
5A						
5B						
5C						
5D						
5E						
5F						
60	CIRQ	addr			3	Clear interrupt request at addr
61	SIRQ	addr			3	Set interrupt request at addr
62	WAIT				1	Halt execution until interrupt
63	RETI				1	Return from interrupt
64	STF	#imm16			3	Set flags specified by immediate mask
64	ST{flag}				3	Set flag specified
64	HALT	!128	!0		3	Halt execution
65	CLF	#imm16			3	Clear flags specified by immediate mask
65	CL{flag}				3	Clear flag specified
66						
67						
68	NOT	dst			2	Bitwise NOT of dst register
69	NEG	dst			2	Two's complement negate dst register
6A	INC	dst			2	Increment dst register
6B	DEC	dst			2	Decrement dst register
6C	SXT	dst			2	Sign-extend low byte of dst register
6D	SWAP	dst			2	Swap high and low bytes of dst register
6E						
6F						
70	TST	A			1	Test A against A and update flags
71	TST	B			1	Test A against B and update flags
72	TST	C			1	Test A against C and update flags
73	TST	D			1	Test A against D and update flags
74	TST	A	#imm16		3	Test A against immediate
75	TST	B	#imm16		3	Test B against immediate
76	TST	C	#imm16		3	Test C against immediate
77	TST	D	#imm16		3	Test D against immediate
78	CMP	A			1	Compare A with A
79	CMP	B			1	Compare A with B
7A	CMP	C			1	Compare A with C
7B	CMP	D			1	Compare A with D
7C	CMP	A	#imm16		3	Compare A with immediate
7D	CMP	B	#imm16		3	Compare B with immediate
7E	CMP	C	#imm16		3	Compare C with immediate
7F	CMP	D	#imm16		3	Compare D with immediate
80	AND	A			1	Logical AND A with A
81	AND	B			1	Logical AND A with B
82	AND	C			1	Logical AND A with C
83	AND	D			1	Logical AND A with D
84	AND	#imm8			2	Logical AND A with immediate
85	AND	#imm16			3	Logical AND A with immediate
86	AND	dst	src		2	Logical AND dst register with src register
87						
88	OR	A			1	Logical OR A with A
89	OR	B			1	Logical OR A with B
8A	OR	C			1	Logical OR A with C
8B	OR	D			1	Logical OR A with D
8C	OR	#imm8			2	Logical OR A with immediate
8D	OR	#imm16			3	Logical OR A with immediate
8E	OR	dst	src		2	Logical OR dst register with src register
8F						
90	XOR	A			1	Logical XOR A with A
91	XOR	B			1	Logical XOR A with B
92	XOR	C			1	Logical XOR A with C
93	XOR	D			1	Logical XOR A with D
94	XOR	#imm8			2	Logical XOR A with immediate
95	XOR	#imm16			3	Logical XOR A with immediate
96	XOR	dst	src		2	Logical XOR dst register with src register
97						
98	SHL	A			1	Shift A left by one
99	SHL	B			1	Shift B left by one
9A	SHL	C			1	Shift C left by one
9B	SHL	D			1	Shift D left by one
9C	SHL	#imm8			2	Shift A left by immediate
9D	SHL	#imm16			3	Shift A left by immediate
9E	SHL	dst	src		2	Shift dst register left by src register
9F						
A0	SHR	A			1	Logical shift A right by one
A1	SHR	B			1	Logical shift B right by one
A2	SHR	C			1	Logical shift C right by one
A3	SHR	D			1	Logical shift D right by one
A4	SHR	#imm8			2	Logical shift A right by immediate
A5	SHR	#imm16			3	Logical shift A right by immediate
A6	SHR	dst	src		2	Logical shift dst register right by src register
A7						
A8	SAR	A			1	Arithmetic shift A right by one
A9	SAR	B			1	Arithmetic shift B right by one
AA	SAR	C			1	Arithmetic shift C right by one
AB	SAR	D			1	Arithmetic shift D right by one
AC	SAR	#imm8			2	Arithmetic shift A right by immediate
AD	SAR	#imm16			3	Arithmetic shift A right by immediate
AE	SAR	dst	src		2	Arithmetic shift dst register right by src register
AF						
B0	ROL	A			1	Rotate A left by one
B1	ROL	B			1	Rotate B left by one
B2	ROL	C			1	Rotate C left by one
B3	ROL	D			1	Rotate D left by one
B4	ROL	#imm8			2	Rotate A left by immediate
B5	ROL	#imm16			3	Rotate A left by immediate
B6	ROL	dst	src		2	Rotate dst register left by src register
B7						
B8	ROR	A			1	Rotate A right by one
B9	ROR	B			1	Rotate B right by one
BA	ROR	C			1	Rotate C right by one
BB	ROR	D			1	Rotate D right by one
BC	ROR	#imm8			2	Rotate A right by immediate
BD	ROR	#imm16			3	Rotate A right by immediate
BE	ROR	dst	src		2	Rotate dst register right by src register
BF						
C0	ADD	A			1	Add A to A
C1	ADD	B			1	Add B to A
C2	ADD	C			1	Add C to A
C3	ADD	D			1	Add D to A
C4	ADD	#imm8			2	Add immediate to A
C5	ADD	#imm16			3	Add immediate to A
C6	ADD	dst	src		2	Add src to dst register
C7						
C8	SUB	A			1	Subtract A from A
C9	SUB	B			1	Subtract B from A
CA	SUB	C			1	Subtract C from A
CB	SUB	D			1	Subtract D from A
CC	SUB	#imm8			2	Subtract immediate from A
CD	SUB	#imm16			3	Subtract immediate from A
CE	SUB	dst	src		2	Subtract src from dst register
CF						
D0	ADC	A			1	Add A plus carry to A
D1	ADC	B			1	Add B plus carry to A
D2	ADC	C			1	Add C plus carry to A
D3	ADC	D			1	Add D plus carry to A
D4	ADC	#imm8			2	Add immediate plus carry to A
D5	ADC	#imm16			3	Add immediate plus carry to A
D6	ADC	dst	src		2	Add src plus carry to dst register
D7						
D8	SBB	A			1	Subtract A plus borrow from A
D9	SBB	B			1	Subtract B plus borrow from A
DA	SBB	C			1	Subtract C plus borrow from A
DB	SBB	D			1	Subtract D plus borrow from A
DC	SBB	#imm8			2	Subtract immediate plus borrow from A
DD	SBB	#imm16			3	Subtract immediate plus borrow from A
DE	SBB	dst	src		2	Subtract src plus borrow from dst register
DF						
E0	MUL	A			1	Multiply A by A
E1	MUL	B			1	Multiply A by B
E2	MUL	C			1	Multiply A by C
E3	MUL	D			1	Multiply A by D
E4	MUL	#imm8			2	Multiply A by immediate
E5	MUL	#imm16			3	Multiply A by immediate
E6	MUL	dst	src		2	Multiply dst register by src register
E7						
E8	MULH	A			1	High-word multiply A by A
E9	MULH	B			1	High-word multiply A by B
EA	MULH	C			1	High-word multiply A by C
EB	MULH	D			1	High-word multiply A by D
EC	MULH	#imm8			2	High-word multiply A by immediate
ED	MULH	#imm16			3	High-word multiply A by immediate
EE	MULH	dst	src		2	High-word multiply dst register by src register
EF						
F0	DIV	A			1	Divide A by A
F1	DIV	B			1	Divide A by B
F2	DIV	C			1	Divide A by C
F3	DIV	D			1	Divide A by D
F4	DIV	#imm8			2	Divide A by immediate
F5	DIV	#imm16			3	Divide A by immediate
F6	DIV	dst	src		2	Divide dst register by src register
F7						
F8	MOD	A			1	Modulo A by A
F9	MOD	B			1	Modulo A by B
FA	MOD	C			1	Modulo A by C
FB	MOD	D			1	Modulo A by D
FC	MOD	#imm8			2	Modulo A by immediate
FD	MOD	#imm16			3	Modulo A by immediate
FE	MOD	dst	src		2	Modulo dst register by src register
FF						
