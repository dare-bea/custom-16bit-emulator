Mnemonic       , Opcode    , Bytes, Description
"LDI reg, #imm", 0x00..0x03,     3, "Load immediate value into register"
"LDA addr"     , 0x08      ,     3, "Load value from memory address into accumulator"
"LDA offset, SP", 0x09      ,     2, "Load value from stack pointer offset by offset into accumulator"
"LDA addr, reg", 0x0C..0x0F,     3, "Load value from memory address offset by register into accumulator"
"STA addr"     , 0x11      ,     3, "Store value from accumulator into memory address"
"STA offset, SP", 0x12      ,     2, "Store value from accumulator into stack pointer offset by offset"
"STA addr, reg", 0x14..0x17,     3, "Store value from accumulator into memory address offset by register"
"STW addr"     , 0x18      ,     3, "Store word from accumulator into memory address"
"STW offset, SP", 0x19      ,     2, "Store word from accumulator into stack pointer offset by offset"
"STW addr, reg", 0x1C..0x1F,     3, "Store word from accumulator into memory address offset by register"
"NOP"          , 0x20      ,     1, "No operation. Equivalent to `MOV A, A`."
"MOV reg, reg" , 0x20..0x2F,     1, "Move value from one register to another"
"MOV SP, reg"   , 0x30..0x33,     1, "Move value from register to stack pointer"
"MOV reg, SP"   , 0x34..0x37,     1, "Move value from stack pointer to register"
"AND reg"      , 0x40..0x43,     1, "Bitwise AND value from register with accumulator"
"OR reg"       , 0x44..0x47,     1, "Bitwise OR value from register with accumulator"
"XOR reg"      , 0x48..0x4B,     1, "Bitwise XOR value from register with accumulator"
"SHL reg"      , 0x4C..0x4F,     1, "Shift accumulator left by value from register"
"SHR reg"      , 0x50..0x53,     1, "Shift accumulator right by value from register"
"ADD reg"      , 0x64..0x67,     1, "Add value from register to accumulator"
"SUB reg"      , 0x68..0x6B,     1, "Subtract value from register from accumulator"
"ROL reg"      , 0x6C..0x6F,     1, "Rotate accumulator left by value from register"
"ROR reg"      , 0x70..0x73,     1, "Rotate accumulator right by value from register"
"ADC reg"      , 0x80..0x83,     1, "Add value from register and carry flag to accumulator"
"SBC reg"      , 0x84..0x87,     1, "Subtract value from register and borrow flag from accumulator"
"NEG reg"      , 0x90..0x93,     1, "Negate value in register"
"NOT reg"      , 0x94..0x97,     1, "Bitwise NOT of register"
"INC reg"      , 0x98..0x9B,     1, "Increment value in register"
"DEC reg"      , 0x9C..0x9F,     1, "Decrement value in register"
"CMP reg"      , 0xA0..0xA3,     1, "Compare value from register with accumulator"
"TST reg"      , 0xA4..0xA7,     1, "Test bits in register against accumulator"
"CMP reg, #imm", 0xA8..0xAB,     3, "Compare immediate value with register"
"TST reg, #imm", 0xAC..0xAF,     3, "Test bits in immediate value against register"
"JMP addr"     , 0xC0      ,     3, "Jump to address"
"JMP near"     , 0xC1      ,     2, "Jump to near address"
"JMP offset, SP", 0xC2      ,     2, "Jump to stack pointer offset by offset"
"CALL addr"    , 0xC3      ,     3, "Call subroutine at address"
"JMP addr, reg", 0xC4..0xC7,     3, "Jump to address offset by register"
"Jcc addr"     , 0xC8..0xCF,     3, "Jump to address if condition is met"
"PUSH PC"      , 0xD4      ,     1, "Push program counter onto stack"
"RET"          , 0xD5      ,     1, "Return from subroutine"
"POP PC"       , 0xD5      ,     1, "Pop value from stack into program counter"
"PUSHF"        , 0xD6      ,     1, "Push flags onto stack"
"POPF"         , 0xD7      ,     1, "Pop flags from stack"
"PUSH reg"     , 0xD8..0xDB,     1, "Push value from register onto stack"
"POP reg"      , 0xDC..0xDF,     1, "Pop value from stack into register"
"CIRQ #imm"    , 0xF0      ,     2, "Clear interrupt request"
"SIRQ #imm"    , 0xF1      ,     2, "Set interrupt request"
"WAIT"         , 0xF2      ,     1, "Wait for interrupt"
"RETI"         , 0xF3      ,     1, "Return from interrupt"
"CLF flags"    , 0xFE      ,     2, "Clear flags"
"STF flags"    , 0xFF      ,     2, "Set flags"
"HLT"          , 0xFF 0x80 ,     2, "Halt execution"